package main

import (
//	"fmt"
	"io"
	"log"
	"net"
	"net/http"
	"net/http/httputil"
	"net/url"
	"strings"
	"time"
)

const (
	reverseProxyPort = "8080"
	forwardProxyPort = "8081"
	backendServerURL = "http://localhost:3000" // Target for the reverse proxy
)

// handleReverseProxy forwards requests to the backend server.
func handleReverseProxy(w http.ResponseWriter, r *http.Request) {
	targetURL, err := url.Parse(backendServerURL)
	if err != nil {
		log.Printf("Error parsing backend server URL: %v", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return
	}

	proxy := httputil.NewSingleHostReverseProxy(targetURL)

	// Update the request host and X-Forwarded-Host header
	r.Host = targetURL.Host
	r.Header.Set("X-Forwarded-Host", r.Header.Get("Host"))
	r.URL.Scheme = targetURL.Scheme
	r.URL.Host = targetURL.Host

	log.Printf("Reverse Proxy: Forwarding request for %s to %s", r.RemoteAddr, targetURL)
	proxy.ServeHTTP(w, r)
}

// handleForwardProxy handles requests for the forward proxy.
func handleForwardProxy(w http.ResponseWriter, r *http.Request) {
	log.Printf("Forward Proxy: Received request for %s %s from %s", r.Method, r.URL.String(), r.RemoteAddr)

	if r.Method == http.MethodConnect {
		// Handle HTTPS CONNECT requests
		handleHTTPSConnect(w, r)
	} else {
		// Handle HTTP requests
		handleHTTP(w, r)
	}
}

// handleHTTP forwards plain HTTP requests.
func handleHTTP(w http.ResponseWriter, r *http.Request) {
	resp, err := http.DefaultTransport.RoundTrip(r)
	if err != nil {
		log.Printf("Forward Proxy: Error forwarding HTTP request %s: %v", r.URL.String(), err)
		http.Error(w, err.Error(), http.StatusServiceUnavailable)
		return
	}
	defer resp.Body.Close()

	log.Printf("Forward Proxy: Successfully forwarded HTTP request %s, got status %s", r.URL.String(), resp.Status)

	// Copy headers from the response to the client
	for key, values := range resp.Header {
		for _, value := range values {
			w.Header().Add(key, value)
		}
	}
	w.WriteHeader(resp.StatusCode)
	io.Copy(w, resp.Body)
}

// handleHTTPSConnect handles HTTPS CONNECT requests by establishing a tunnel.
func handleHTTPSConnect(w http.ResponseWriter, r *http.Request) {
	destConn, err := net.DialTimeout("tcp", r.Host, 10*time.Second)
	if err != nil {
		log.Printf("Forward Proxy: Error dialing destination %s for CONNECT: %v", r.Host, err)
		http.Error(w, err.Error(), http.StatusServiceUnavailable)
		return
	}

	log.Printf("Forward Proxy: Established TCP tunnel to %s for %s", r.Host, r.RemoteAddr)
	w.WriteHeader(http.StatusOK) // Inform client that connection is established

	hijacker, ok := w.(http.Hijacker)
	if !ok {
		log.Printf("Forward Proxy: Hijacking not supported for %s", r.Host)
		http.Error(w, "Hijacking not supported", http.StatusInternalServerError)
		return
	}

	clientConn, _, err := hijacker.Hijack()
	if err != nil {
		log.Printf("Forward Proxy: Error hijacking connection for %s: %v", r.Host, err)
		http.Error(w, err.Error(), http.StatusBadGateway)
		return
	}

	// Goroutine to copy data from client to destination
	go transfer(destConn, clientConn)
	// Goroutine to copy data from destination to client
	go transfer(clientConn, destConn)
}

// transfer copies data between two connections and closes them when done.
func transfer(destination io.WriteCloser, source io.ReadCloser) {
	defer destination.Close()
	defer source.Close()
	written, err := io.Copy(destination, source)
	if err != nil {
		// Ignore "use of closed network connection" errors as they are expected when one side closes.
		if !strings.Contains(err.Error(), "use of closed network connection") {
			log.Printf("Error during data transfer: %v, bytes transferred: %d", err, written)
		}
	}
}

func main() {
	// Start Reverse Proxy
	go func() {
		muxReverse := http.NewServeMux()
		muxReverse.HandleFunc("/", handleReverseProxy)
		log.Printf("Starting Reverse Proxy on port %s, forwarding to %s...", reverseProxyPort, backendServerURL)
		if err := http.ListenAndServe(":"+reverseProxyPort, muxReverse); err != nil {
			log.Fatalf("Reverse Proxy failed to start: %v", err)
		}
	}()

	// Start Forward Proxy
	go func() {
		muxForward := http.NewServeMux()
		muxForward.HandleFunc("/", handleForwardProxy)
		log.Printf("Starting Forward Proxy on port %s...", forwardProxyPort)
		// For a production forward proxy, you might want to use http.Server with custom timeouts.
		if err := http.ListenAndServe(":"+forwardProxyPort, muxForward); err != nil {
			log.Fatalf("Forward Proxy failed to start: %v", err)
		}
	}()

	// Keep the main goroutine alive
	log.Println("Proxy servers starting...")
	select {} // Block forever
}
